class UnionFind:
    def __init__(self, elements):
        self.parent = {element: element for element in elements}

    def find(self, element):
        # 递归查找元素的根（代表元），同时应用路径压缩
        if self.parent[element] != element:
            self.parent[element] = self.find(self.parent[element])  #路径压缩：将每一个元素的parent element转变为元素的根（代表元）
        return self.parent[element]


    def union(self, element_1, element_2):
        # 将两个元素所在的集合合并
        root_1 = self.find(element_1)
        root_2 = self.find(element_2)
        if root_1 != root_2:   #如果两个元素具有不同的根（代表元），则将其中一个元素的代表元变成另一个元素的代表元的代表元。这样就将两个集合合并为具有同一个代表元。
            self.parent[root_2] = root_1

"""

“并查集”（Union-Find）是一种处理不相交集合（Disjoint Sets）的数据结构，它非常有效地支持两种操作：查找（Find）和合并（Union）。
在解决一些涉及元素分组和分组成员关系的问题时，在解决一些需要快速合并多个集合并且频繁检查元素所属集合的问题时非常有用。它被广泛应用于网络连接、最小生成树、图的连通分量分析等领域。

基本概念：
查找（Find）：确定某个元素属于哪个集合，或者说确定集合的“代表元”（通常是集合的根节点）。
合并（Union）：将两个集合合并为一个集合。

并查集的工作原理：
初始化：最开始时，每个元素都是一个独立的集合，自己是自己的代表元。

查找：为了找出元素所属的集合，我们沿着指向代表元的指针移动，直到找到根元素，根元素是自己的代表元，代表了整个集合。

路径压缩：在执行查找操作时，可以进行路径压缩，即将查找路径上的每个节点直接连接到根节点。这个优化减少了后续查找操作的时间复杂度。

合并：要合并两个集合，只需将一个集合的根元素指向另一个集合的根元素。

术语解释：
代表元（Representative）和根元素（Root Element）：
在并查集中，每个集合都有一个“代表元”或“根元素”。这个元素在某种意义上代表了整个集合。
在一开始，每个元素都是自己集合的代表元，即每个元素都是一个独立集合。
随着合并操作，某些元素会成为其他元素的父元素。在这样的树状结构中，根元素（或代表元）是唯一一个没有父元素的元素，它代表了整个集合。

路径压缩（Path Compression）：
在查找一个元素的代表元时，我们通常从该元素开始，沿着父元素指针向上移动，直到达到根元素。
“路径压缩”是并查集的一个优化技术。当我们在查找过程中经过一些节点时，我们将这些节点直接连接到根元素。这样，下一次查找同一个集合中的任何一个元素时，查找路径将大大缩短，提高了查找效率。

合并（Union）：
合并操作是指将两个集合合并成一个集合。在并查集中，这通常通过将一个集合的根元素指向另一个集合的根元素来实现。


时间复杂度：
对于包含路径压缩的并查集，几乎所有的操作（Find 和 Union）都可以接近常数时间复杂度进行。
准确来说，它的复杂度是 O(α(N))，其中 α 是阿克曼函数（Ackermann Function）的逆函数，它增长非常缓慢，对于所有实际的输入大小 N，α(N) 都可以认为是一个很小的常数。


并查集的工作示例：
假设有元素 A、B、C、D，初始时它们都是独立的集合：
A  B  C  D

如果我们合并 A 和 B，然后合并 C 和 D，结构会变成：
A   C
|   |
B   D
此时，A 是集合 {A, B} 的代表元，C 是集合 {C, D} 的代表元。

如果我们再合并 A 和 C，结构变为：
    A
   / \
  B   C
       |
       D
现在，A 是集合 {A, B, C, D} 的代表元。

如果我们要查找 B 的代表元，我们会从 B 开始，向上找到 A。
如果我们在查找过程中应用路径压缩，那么 B 之后会直接指向 A，这样下次查找 B 或其它元素的代表元时就更快了。


并查集的字典实现工作示例：
通过一个具体的例子来说明使用字典实现的并查集在操作前后的状态变化。
假设我们有四个元素：'A', 'B', 'C', 'D'。我们的目标是使用并查集来管理这些元素的集合关系。

初始状态
最初，每个元素自成一集合。并查集的字典表示可能如下：
parent = {
    'A': 'A',
    'B': 'B',
    'C': 'C',
    'D': 'D'
}
在这个状态下，每个元素的父元素是它自己，表明每个元素都是一个独立的集合。

合并操作
现在，假设我们要合并 'A' 和 'B' 到同一个集合，以及 'C' 和 'D' 到另一个集合。合并操作后，字典可能会更新为：
parent = {
    'A': 'B',  # A 和 B 现在在同一个集合，我们可以选择 B 作为代表元
    'B': 'B',
    'C': 'D',  # C 和 D 在同一个集合，D 是代表元
    'D': 'D'
}
在这个状态下，'A' 的父元素是 'B'，表示 'A' 和 'B' 属于同一个集合，类似地，'C' 的父元素是 'D'。

进一步合并
如果我们进一步将 'B' 和 'C' 合并，形成一个包含所有元素的集合，字典会更新为：
parent = {
    'A': 'B',
    'B': 'D',  # B 的代表元现在是 D，因为 B 和 C 合并，C 的代表元是 D
    'C': 'D',
    'D': 'D'
}
现在所有元素都属于一个集合，'D' 是这个集合的代表元。

查找操作
在这种状态下，如果我们查找 'A' 的代表元，算法会沿着链 'A' -> 'B' -> 'D' 进行，最终得到 'D'。这就是 'A' 所在集合的代表元。

路径压缩
为了优化查找操作，可以应用路径压缩，使得每个元素直接指向最终的代表元。在多次查找操作后，字典可能会变成：
parent = {
    'A': 'D',  # 路径压缩后，A 直接指向 D
    'B': 'D',
    'C': 'D',
    'D': 'D'
}
"""