Dijkstra算法是一种用于在图中找到从单一源点到所有其他节点的最短路径的算法。它适用于带有非负权重的有向和无向图。算法的核心思想是贪心法，每次都选择未处理的最近的顶点，更新其邻居的距离。

Dijkstra算法的步骤：
初始化：将所有节点的最短路径估计值设为无穷大，除了源点设为0，因为源点到自己的最短距离当然是0。

选择最短路径未知的顶点的最小距离：在所有未被处理的顶点中找到距离源点最近的一个。

更新邻居的距离：对于选择的顶点，考虑其所有未处理的邻居，计算通过当前顶点到邻居的距离，如果这个距离小于已知的最短路径，则更新这个邻居的最短路径。

标记为已处理：当考虑了所有邻居并更新了距离后，将此顶点标记为已处理。已处理的顶点不会再次检查或更新。

重复：重复第2步到第4步，直到所有顶点都被处理。

完成：算法完成后，可以得到从源点到所有顶点的最短路径。


Dijkstra算法的时间复杂度：O((V + E) log V)  （V是顶点数量，E是边数量）
V O(log V) + E O(log V) = O((V + E) log V)
（需要格外注意的是，在此算法中，虽然有while pq和检查某顶点所有邻接顶点的两层循环，但两层循环的次数并非简单的相乘关系。）
（详见代码，注释分析每行代码的时间复杂度）


举例说明：
假设我们有一个图，包含5个顶点（A, B, C, D, E），它们之间的距离如下：

A到B的距离为6。
A到D的距离为1。
B到A的距离为6。
B到C的距离为5。
B到D的距离为2。
B到E的距离为2。
C到B的距离为5。
C到E的距离为5。
D到A的距离为1。
D到B的距离为2。
D到E的距离为1。
E到B的距离为2。
E到C的距离为5。
E到D的距离为1。
我们希望找到从顶点A到图中所有其他顶点的最短路径。

步骤详解：
初始化：将所有顶点的最短路径值设为无限大，除了源点A设为0。所以初始时，我们有：
A: 0
B: ∞
C: ∞
D: ∞
E: ∞
并将所有节点标记为未处理。

处理顶点A：检查顶点A的所有邻居，更新它们的距离（如果A的距离加上A到该邻居的距离比该邻居当前的距离小）：
A到B的距离更新为6（0 + 6），
A到D的距离更新为1（0 + 1）。

所以现在我们有：
A: 0
B: 6
D: 1
C: ∞
E: ∞
顶点A现在被标记为已处理。

选择下一个顶点：在未处理的顶点中，我们选择最小的距离顶点，这里是D（距离为1）。

处理顶点D：对于D的所有未处理邻居，更新距离：
D到B的距离现在是3（1 + 2），因为1 + 2 < 6。
D到E的距离更新为2（1 + 1）。

现在我们有：
A: 0
B: 3 (更新)
D: 1
E: 2 (更新)
C: ∞
顶点D现在被标记为已处理。

重复选择和处理：重复选择未处理顶点中距离最小的顶点，然后更新其邻居的距离。下一个顶点是E（距离为2）。

处理顶点E：对于E的所有未处理邻居，更新距离：
E到B的距离不更新，因为E到B的距离是4（2 + 2），不小于当前B的最短路径3。
E到C的距离更新为7（2 + 5）。

现在我们有：
A: 0
B: 3
D: 1
E: 2
C: 7 (更新)
顶点E现在被标记为已处理。

继绀处理：接下来，顶点B（距离为3）被处理，但它的所有邻居要么已经被处理，要么距离不需要更新。

最后处理顶点C：因为所有其他顶点都已经处理过，剩下顶点C。

完成：所有顶点都已经被处理，我们得到了从A到所有其他顶点的最短路径。

最终结果：
从A出发，到所有顶点的最短路径如下：
A到A：0
A到B：3
A到C：7
A到D：1
A到E：2
这些值就代表了从A出发到达各个顶点的最短路径的长度。

在实际的代码实现中，我们还会保存“前驱节点”信息，以便能够重建最短路径的实际序列。

