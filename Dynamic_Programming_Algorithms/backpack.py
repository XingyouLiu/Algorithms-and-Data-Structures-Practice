def knapsack(items_prices, items_weight, max_weight):
    """
    状态：通常定义为一个二维数组 dp[i][w]，表示考虑前 i 件物品时，背包容量为 w 时的最大价值
    注意：i并不表示放入背包的物品数量，而是表示在物品列表中遍历到了第i件物品（索引为 i-1），即从第一件物品开始考虑要不要加入背包，一直考虑到了第i件物品
    """
    items_num = len(items_prices)
    dp = [[0 for _ in range(max_weight + 1)] for _ in range(items_num + 1)]
    #dp = [[0] * (max_weight + 1)] * (items_num + 1) 为什么不能这样生成矩阵？见附注
    for i in range(1, items_num + 1):
        for w in range(1, max_weight + 1):
            if items_weight[i - 1] > w: #如果物品重量大于目前背包容量上限，则直接选择不加入该物品（此时，该容量下的最大价值与未加入该物品时的该容量下最大价值一致）
                dp[i][w] = dp[i - 1][w]
            else:
    #如果物品重量小于目前背包容量上限，则对比两种情况下的物品总价值哪个更大（决定是保留之前的最大价值，还是加入这个物品来获得可能更大的价值！）
    #情况一：不加入该物品（此时价值与未加入该物品时的该容量下最大价值一致）
    #情况二：加入该物品（此时价值等于未加入该物品时、且容量为当前最大容量减去该物品重量时的最大价值，再加上该物品的价值，即为此时的总价值）
    #注：情况二中，取用未加入该物品且容量为w-items_weight[i - 1]的情形作为未加入该物品时的最大价值，隐式地保障了加入该物品后也绝对不会容量超标，也保障了加入该物品后刚好能占满容量
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - items_weight[i - 1]] + items_prices[i - 1])

    return dp[items_num][max_weight]


print(knapsack([5,2,10], [3,4,5], 10))


"""
附注：为什么使用 [[0] * (max_weight + 1)] * (items_num + 1) 初始化动态规划数组 dp 会导致问题？
在 Python 中，列表（list）是可变的（mutable）。当使用 * 操作符来复制列表时，实际上只是复制了对列表的引用，而不是列表本身。
这意味着，如果列表中的元素是可变的（比如另一个列表），那么所有的复制都会指向同一个列表。

dp = [[0] * (max_weight + 1)] * (items_num + 1)
这行代码实际上创建了 items_num + 1 个指向同一个列表 [0] * (max_weight + 1) 的引用。也就是说，dp 中的所有行都是指向同一个列表的引用。
因此，当修改 dp 中的任何一个元素时，所有行都会受到影响。
举例
假设 max_weight 为 3，items_num 为 2，那么 dp 初始化后看起来像这样：
dp = [
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0]
]
如果我们修改 dp[0][1] = 1，那么所有行的第二个元素都会变成 1：
dp = [
    [0, 1, 0, 0],
    [0, 1, 0, 0],
    [0, 1, 0, 0]
]
这显然不是我们想要的结果。

正确的初始化方式
为了避免这个问题，我们应该使用列表推导式来创建 dp，这样每行都是独立的：
dp = [[0 for _ in range(max_weight + 1)] for _ in range(items_num + 1)]
这种方式确保每一行都是一个独立的列表，对其中一行的修改不会影响到其他行。这对于实现动态规划算法是至关重要的，因为我们需要保持每一步的计算结果独立。
"""

